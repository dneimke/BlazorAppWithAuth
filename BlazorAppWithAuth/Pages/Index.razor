@page "/"
@using BlazorAppWithAuth.Services
@using System.Security.Claims
@inject WrapperService _Wrapper
@inject WrapperService2 _Wrapper2
@inject AuthenticationStateProvider GetAuthenticationStateAsync


<PageTitle>Index</PageTitle>

<h1>Testing dependencies</h1>

<h3>Failing method</h3>

<p>
	Clicking the first button will fail because when the SignalR connection is made, there's no
	HttpContext, so WrapperService1 cannot be constructed.
</p>

<p>
	This method attempts to use the Wrapper service which has the ClaimsPrincipal constructed
	as a cross-cutting concern via dependency injection.
</p>

<pre>
void HandleClick1()
{
	try
	{
		var result = _Wrapper.UserHasSpecialAccess();
		_results.Add($"HandleClick1 -> {result}");			
	}
	catch (Exception ex)
	{
		_error = ex.ToString();
	}

}
</pre>

<h3>Successful method</h3>

<p>
	The second button succeeds because the ClaimsPrincipal is stored locally on the initial request
	and then passed in to services as required. This doesn't feel like a great way to build scalable
	software. I'm hoping there's a way to construct a <code>ClaimsPrincipal</code> via dependency injection 
	so that the cross-cutting concerns can be managed more efficiently.
</p>

<pre>
void HandleClick2()
{
	if(_principal is not null)
	{
		var context = new UserContext(_principal);
		var result = _Wrapper2.UserHasSpecialAccess(context);
		_results.Add($"HandleClick2 -> {result}");
	}
}
</pre>


<p>
	<strong>
		Note: When you are logge-in, clicking Button 2 will return a `True` result.  You need to register 
		for an account before loginng it. Make sure you verify your account when you register!!
	</strong>
</p>

<div class="my-4">
	<button @onclick="HandleClick1">Check 1</button>
	<button @onclick="HandleClick2">Check 2</button>
</div>

<hr />

@if(_results.Any()) 
{
	<p class="bg-info p-4 mb-5">
		<ul>
			@foreach(var result in _results)
			{
				<li>Result: @result</li>
			}
		</ul>
		
	</p>
}

@if(!string.IsNullOrEmpty(_error))
{
	<p class="bg-warning text-danger p-4">
		@_error
	</p>
}




@code 
{
	[Parameter] public ClaimsPrincipal User { get; set; }

	string _error { get; set; } = "";
	public List<string> _results { get; set; } = new();
	ClaimsPrincipal? _principal { get; set; }

	protected async override Task OnInitializedAsync()
	{
		var authstate = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();
		_principal = authstate.User;
	}

	void HandleClick1()
	{
		try
		{
			var result = _Wrapper.UserHasSpecialAccess();
			_results.Add($"HandleClick1 -> {result}"); // fails 😔			
		}
		catch (Exception ex)
		{
			_error = ex.ToString();
		}

	}

	void HandleClick2()
	{
		if(_principal is not null)
		{
			var context = new UserContext(_principal);
			var result = _Wrapper2.UserHasSpecialAccess(context);
			_results.Add($"HandleClick2 -> {result}"); // succeeds
		}
	}
}
